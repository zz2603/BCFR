---
title: "data merging and cleaning"
author: "Ziyi Zhao"
date: "3/16/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)

```

The purpose of this code file is to gather all related information from each spreadsheet.

# Import dataset

All spreadsheets in xlsx dataset are converted into csv file separately, and each csv file is named with the name of spreadsheet.

```{r}
## import dataset 'family membership.csv'
fam_mem <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/family_membership.csv") %>% 
  janitor::clean_names()

## import dataset 'bc_epi.csv'
bc_epi <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/bc_epi.csv") %>% 
  janitor::clean_names()

## import dataset 'individual.csv'
indvd <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/individual.csv") %>% 
  janitor::clean_names()

## import dataset 'nutrient.csv'
nutrnt <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/nutrient.csv") %>% 
  janitor::clean_names()

## import dataset 'bc_rx.csv'
bc_rx <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/bc_rx.csv") %>% 
  janitor::clean_names()

## import dataset 'bc_surgery.csv'
bc_surgry <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/bc_surgery.csv") %>% 
  janitor::clean_names()

## import dataset 'bc_mutation.csv'
bc_mutat <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/bc_mutation.csv") %>% 
  janitor::clean_names()

## import dataset 'bc_epi_status.csv'
bc_epi_stat <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/bc_epi_status.csv") %>% 
  janitor::clean_names()

## import dataset 'pregnancy.csv'
pregncy <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/pregnancy.csv") %>% 
  janitor::clean_names()

## import dataset 'cancer.csv'
cancer <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/cancer.csv") %>% 
  janitor::clean_names()

## import dataset 'family.csv'
famly <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/family.csv") %>% 
  janitor::clean_names()

## import dataset 'derived_var.csv'
derived_var <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/derived_var.csv") %>% 
  janitor::clean_names()

## import dataset 'bc_invasive.csv'
bc_invas <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/bc_invasive.csv") %>% 
  janitor::clean_names()

## import dataset 'bc_confirmation.csv'
bc_confirm <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/bc_confirmation.csv") %>% 
  janitor::clean_names()

## import dataset 'Hawaii_diet.csv'
hawaii_dt <- read_csv("C:/Users/zzhao/Desktop/BCFR/data/Hawaii_diet.csv") %>% 
  janitor::clean_names()

```

# merging and cleaning dataset

There are `r dim(bc_epi)[1]` unique rows (subjects) in total. However, not all datasets have unique subjects or contain all subjects. The first step is to select important variable from these datasets, such as follow-up, nutrient, other confounding covariates.

## Merge the dataset without duplicated rows.

```{r}
## build a new dataset by binding fam_mem and bc_epi
bc_data <- left_join(fam_mem,bc_epi,by="new_id") %>% 
  select(-c(center_no.y,aus_education))

## the name of center number is changes due to previous merging
## rename the center number
colnames(bc_data)[2] <- "center_no"

## merge bc_data with indvd and create a new table bc_data1
bc_data1 <- left_join(bc_data,indvd,by="new_id") %>% 
  select(-c(center_no.y,diet_q_aus))
colnames(bc_data1)[2] <- "center_no"

## merge bc_data1 with bc_mutation and create a new table bc_data2
bc_data2 <- left_join(bc_data1,bc_mutat,by="new_id") %>% 
  select(-center_no.y)
colnames(bc_data2)[2] <- "center_no"

## merge bc_data2 with bc_rx and create a new table bc_data3
bc_data3 <- left_join(bc_data2,bc_rx,by="new_id") %>% 
  select(-center_no.y)
colnames(bc_data3)[2] <- "center_no"

## merge bc_data3 with derived_var and create a new table bc_data4
bc_data4 <- left_join(bc_data3,derived_var,by="new_id") %>% 
  select(-center_no.y)
colnames(bc_data4)[2] <- "center_no"

## merge bc_data4 with famly and create a new table bc_data5
bc_data5 <- left_join(bc_data4,famly,by="family_id") %>% 
  select(-center_no.y)
colnames(bc_data5)[2] <- "center_no"

## before merging bc_data5 with nutrnt, select variables for MDS and aMED
## create a new table mds_nutrnt
## merge bc_data5 with mds_nutrnt and create a new table bc_data6
mds_nutrnt <- select(nutrnt,c(new_id,calories_in_food,
                              satur_fat_in_food,monounsat_fat_in_food,
                              food_group_veg_exc_legumes,
                              food_group_potatoes_tubers,
                              total_grain,whole_grain,
                              food_group_all_fruits_inc_juice,
                              food_group_fruit_juice_only,
                              total_fruit,
                              food_group_nuts,
                              food_group_all_dairy,
                              alcohol_in_food,
                              food_group_redmeat_nonprocessed,
                              food_group_processed_redmeat,
                              food_group_poultry,
                              food_group_processed_poultry,
                              food_group_legumes,
                              fish_only))
bc_data6 <- left_join(bc_data5,mds_nutrnt,by="new_id")

```

Since subjects can have more than one tumors, they may cause duplicated rows. It would be very messy if we merge datasets with duplicated rows. We can exclude some rows that we don't need in the study.

## Excluding patients from centers in Australia

```{r}
## create a new dataset without Australian centers
bc_data_exc_aus <- bc_data6 %>% 
  filter(center_no %in% c(1,2,3,5,6))

bc_data_exc_aus %>% group_by(center_no) %>% 
  summarize(freq = n()) %>% 
  knitr::kable() ## generate a table frequency for each center

```

The table above showed the distribution of patients after we exclude the patient from Australia.

## Exclude patient who were diagnosed with breast cancer or had surgery of mastectomy before the date of interview.

### breast cancer diagnosis 

We can use the information from bc_rx and looked at the answer of those two questions. We will exclude patients who answered yes.

```{r}
# there are some patients missed these two questions
# we only exclude people who answered yes
# brca: 2 was denoted as those who answered no
# br_surg_mas: same as above
# 8 and 9 denoted not asked and missing
bc_data_exc_diag_mas <- bc_data_exc_aus %>% 
  filter(is.na(brca)|brca %in% c(2,8,9)) %>% 
  filter(is.na(br_surg_mas)|br_surg_mas %in% c(2,8,9))

## see the distribution of people without diagnosis of breast cancer and mastectomy
bc_data_exc_diag_mas %>% group_by(brca) %>% 
  summarize(freq = n()) %>% 
  knitr::kable()
  
bc_data_exc_diag_mas %>% group_by(br_surg_mas) %>% 
  summarize(freq = n()) %>% 
  knitr::kable()

```

There are 106 subjects who answered 'no' in the question about breast cancer diagnosis.

There are 81 subjects who answered 'no' in the question about mastectomy.

There isn't any any subjects who answered 'yes'. Or they can be unreported.

We can observe there are more than 10,000 patients with NA. We cannot exclude them. We still need to check their date of diagnosis.

Extract the id number of subjects who answered no in breast cancer and mastectomy.

```{r}
# create a new variable that included id of those who answered no in breast cancer diagnosis question
bc_rx_nobc_id <- bc_data_exc_diag_mas %>% filter(brca==2) %>% 
  pull(new_id)

# create a new variable that included id of those who answered no in mastectomy question
bc_rx_nomas_id <- bc_data_exc_diag_mas %>% filter(br_surg_mas==2) %>% 
  pull(new_id)

```

To get the date of diagnosis, we need to get information from cancer.csv. Eliminate the duplicated subjects by only selecting the earliest disgnosis date. Merge with bc_data_exc_diag_mas. 

```{r}
# diagnose date of breast cancer
# data is from cancer.csv
# some patients could get more than one tumor, only use the earliest
dt_dx <- pull(cancer,dxdate) %>% ymd() # convert into date format
# there are 4904 answers that cannot be converted into time formart
na_check <- which(is.na(dt_dx)) # get row number of missing date information
# create a table to see distribution
cancer[na_check,] %>% select(dxdate) %>% 
  group_by(dxdate) %>% summarize(n=n())
# the distribution of missing date is not good, 
# b/c there are so many missing month and day
# we can eliminate the duplicated subjects by selecting the smallest dxdate 
# for those with multiple tumor sites with equal diagnose date, only keep one of them
# some only have age at diagnosis without date and they have more than one tumor 
# pick the smallest age at diagnosis
# we prefer the smallest dxest b/c it is the most accurate
cancer_data_dx <- cancer %>% 
  filter(center_no %in% c(1,2,3,5,6)) %>% 
  select(new_id,agedx,dxdate,dxest) %>% 
  group_by(new_id) %>% 
  mutate(min_dxAge = min(agedx),
         early_dxdate = min(dxdate),
         min_dxest = min(dxest)) %>% 
  filter(dxdate==early_dxdate) %>% 
  filter(agedx==min_dxAge) %>% 
  filter(dxest==min_dxest) %>% 
  distinct()
# we need to make sure if they have unique id
sum(duplicated(cancer_data_dx[,1]))
# it's 0, which means there is no duplicated subjects
cancer_data_dx <- select(cancer_data_dx,-c(min_dxAge,early_dxdate,min_dxest))

# we can merge the cancer data with the data without breast cancer and mas
bc_data7 <- left_join(bc_data_exc_diag_mas,cancer_data_dx,by="new_id")

```

There is a hiding process above I didn't choose to show here. During the filtration of cancer_data_dx, we cannot directly let age of diagnosis equal to the smallest one for each subject id because there are some subjects have different age at diagnosis but exactly same diagnosis date. However, there is only one subject with this problem. After substracted date of diagnosis by date of birth, I find out we can use the smallest age at diagnosis. 

Compare the dxdate and dt_interview among subjects with non-missing date (not fully missing).

```{r}
# there isn't not asked code 88888888
# remove missing and NA
# create a new variable that show if diagnosis date is before interview date
# 1 was denoted as diagnosis date is before interview date 
# 0 vice versa
# see the distribution
bc_data7 %>% filter(dxdate!=99999999) %>% 
  filter(!is.na(dxdate)) %>% 
  select(new_id,dt_interview,age_interview,agedx,dxdate) %>% 
  mutate(diag_bef_intvw = case_when(
    dxdate <= dt_interview ~ 1,
    dxdate > dt_interview ~ 0)) %>% 
  group_by(diag_bef_intvw) %>% 
  summarize(n=n())

```

Except NA and missing, there are 2635 subjects with diagnosis date before interview date and 903 subjects with diagnosis date after interview date. We only keep subjects with diagnosis date after interview date.

We also need to exclude patients who were diagnosed after interview date within two months. 

```{r}
# create a new tibble with interview date and diagnosis date
bc_dx_int <- bc_data7 %>% filter(dxdate!=99999999) %>% 
  filter(!is.na(dxdate)) %>% 
  select(new_id,dt_interview,age_interview,agedx,dxdate)
# create a table to look at the distribution of subjects
bc_dx_int %>% mutate(diag_bef_intvw = case_when(
  dxdate <= dt_interview ~ 1,
  dxdate > dt_interview ~ 0)) %>% 
  group_by(diag_bef_intvw) %>% 
  summarize(n=n())


```

According to the process above, there could be missing month and day in diagnosis date for some subjects and 99 or 9999 can always be greater than those with normal date. We may overestimate the number of subjects with diagnosis date after interview date.

Next step, we are going to extract date information and convert them into date format. The specific variable of year and month are created to identify those with missing month or day. 

```{r}
# extract interview date and convert to date format
date_int <- pull(bc_dx_int,dt_interview) %>% ymd()
# there is one failed to parse, shown as NA
# see the location of NA
which(is.na(date_int))
# view the exact date
pull(bc_dx_int,dt_interview)[2327]
# month and day are missing, shown as 9999
# create a new variable for year of interview
date_int_yr <- year(date_int)
date_int_yr[2327] <- 1997
# create a new variable month of interview
# there is one NA in 2327th subject because of missing in month
date_int_mth <- month(date_int)

# we also need the time point 'two months after diagnosis'
# b/c subjects diagnosed within two months after interview should be excluded
# there are problems of adding 2 months directly
# b/c 12 months have different number of days
# we choose to add 61 days (30.5 days / month)
date_int_two_mth <- date_int + ddays(61)

# extract diagnosis date and convert it into date format
date_dx <- pull(bc_dx_int,dxdate) %>% ymd()
# there are 788 failed to parse
# get the location of NA
which(is.na(date_dx))
# generate a new varaible for those NA's location
date_dx_na <- which(is.na(date_dx))
# view the date
pull(bc_dx_int,dxdate)[date_dx_na]
# create a variable year of diagnosis
date_dx_yr <- year(date_dx) 
# it was formed by those who are successfully converted into date format
# create a new variable for month of diagnosis
date_dx_mth <- month(date_dx)

# we need to fill value of year and month separately for those with missing month and day
# generate a new variable year of diagnosis for those missing month and day
date_dx_miss_yr <- pull(bc_dx_int,dxdate)[date_dx_na] %>% 
  as.character() %>% substr(.,start = 1,stop = 4) %>% as.numeric()
# generate a new variable month of diagnosis for those missing month and day
date_dx_miss_mth <- pull(bc_dx_int,dxdate)[date_dx_na] %>% 
  as.character() %>% substr(.,start = 5,stop = 6) %>% as.numeric()
# there are lots of 99 in months
# b/c some patients do not have info on months
# to avoid error in comparation, change 99 to NA
date_dx_miss_mth[which(date_dx_miss_mth==99)] <- NA

# fill in the value into variable year of diagnosis
for (i in 1:length(date_dx_na)) {
    date_dx_yr[date_dx_na[i]] <- date_dx_miss_yr[i]
    date_dx_mth[date_dx_na[i]] <- date_dx_miss_mth[i]
}

# add those variables in date format to bc_dx_int
bc_dx_int <- add_column(bc_dx_int,
                        date_int,date_int_yr,date_int_mth,date_int_two_mth,
                        .after = "dt_interview") %>% 
  add_column(.,
             date_dx,date_dx_yr,date_dx_mth,
             .after = "dxdate")

```

We already converted these data into date format or separated them apart into year and month. Next, we are going to filter the data by date, year, and month. 

New variables, being used to determine if diagnose date is before interview date, are created and added into the tibble. The table of distribution will be created as well. 

We will use 1 to denote patients whose diagnosed date is before or equal to interview date. Those patient will be excluded; we will use 0 to denote patient who diagnosed date is after interview date.

* filtered the date

```{r}
bc_dx_int %>% mutate(diag_bef_intvw = case_when(
  date_int < date_dx ~ 0,
  date_int >= date_dx ~ 1)) %>% 
  group_by(diag_bef_intvw) %>% 
  summarize(n=n())

# based on the output, the column in date format can be more accurate
# redefine the tibble
bc_dx_int <- bc_dx_int %>% mutate(diag_bef_intvw = case_when(
  date_int < date_dx ~ 0,
  date_int >= date_dx ~ 1))

```

There are 600 subjects with daignosed date after interview date, 2149 subjects with diagnosis date before or equal to interview date, and 789 subjects with NA. The NA is caused by missing value in month and day.

Among those 600 subjects, we need to further check if they are diagnosed with breast cancer within 2 months after date of diagnosis.

```{r}
bc_dx_int %>% filter(diag_bef_intvw==0) %>% 
  mutate(diag_bef_intvw_plus2mth = case_when(
    date_dx > date_int_two_mth ~ 0,
    date_dx <= date_int_two_mth ~1
    )) %>% 
  group_by(diag_bef_intvw_plus2mth) %>% 
  summarize(n=n())
  

```

There are 26 subjects with exact date whose diagnosed date is within 2 months after the interview date. 

Other 574 subjects with exact date whose diagnosed date is after the interview dates (+2 months). 

For those who missed information on month and day, we can looked at year alternatively. But, it could be problematic when years are equal.

* filtered by year

We used 1 to denote those who have equal interview and diagnosis year; 0 denoted those with unequal year of interview and diagnosis.

```{r}
bc_dx_int %>% filter(is.na(diag_bef_intvw)) %>%  
  mutate(diag_equl_intvw_yronly = case_when(
  date_int_yr == date_dx_yr ~ 1,
  date_int_yr != date_dx_yr ~ 0)) %>% 
  group_by(diag_equl_intvw_yronly) %>% 
  summarize(n=n())

# keep the subjects with equal years as 0 
# b/c we need to further make sure if we should exclude them.
bc_dx_int <- bc_dx_int %>% mutate(diag_equl_intvw_yronly = case_when(
  date_int_yr == date_dx_yr ~ 1,
  date_int_yr != date_dx_yr ~ 0),
  diag_bef_intvw_yronly = case_when(
    date_int_yr > date_dx_yr ~ 1,
    date_int_yr <= date_dx_yr ~ 0
  ))

```

We can see there are 26 subjects without exact date but equal years of interview and diagnosis, and 763 subjects without exact date but unequal years of interview and diagnosis. 

We can deal with those 763 subjects by comparing years, but, for those 26 subjects, we need to futher looked at month.

* filter for month

When looking at month, this will indicate if their diagnosis dates are before two months after interview date, because we don't need any subjects who were diagnosed within 2 months after interview date.

We still need to see if there are subjects with equal years and months of interview (+2 months) and diagnosis. If so, we may ask for further information from data source. 

```{r}
bc_dx_int %>% filter(is.na(diag_bef_intvw)) %>% 
  filter(diag_equl_intvw_yronly==1) %>% 
  mutate(diag_equl_intvw_yr_mth = case_when(
    date_int_mth+2 == date_dx_mth ~ 1,
    date_int_mth+2 != date_dx_mth ~ 0
  )) %>% group_by(diag_equl_intvw_yr_mth) %>% 
  summarize(n=n())
         
```

There are 12 subjects with equal years but missing months. We need some help for those 12 subjects to see if we get the information on month.

There are 14 subjects with equal years but different months of interview (+2 months) and diagnosis.

There is no subject with equal years and equal months of interview (+2 months) and diagnosis.

For those 12 subjects, we need more help!!! Or, we can just count them as missing date. It will lose power. We can keep them temporarily.

```{r}
bc_dx_int %>% filter(is.na(diag_bef_intvw)) %>% 
  filter(diag_equl_intvw_yronly==1) %>% 
  mutate(diag_equl_intvw_yr_mth = case_when(
    date_int_mth+2 == date_dx_mth ~ 1,
    date_int_mth+2 != date_dx_mth ~ 0
  )) %>% filter(is.na(diag_equl_intvw_yr_mth))


```

Since there is no equal months of diagnosis and interview (+2 months), we can only include 'greater than' and 'smaller than' symbols in the code.

There may be concerns about months because values of months can go over 12. However, if the months of interview (+2 months) go over 12, it indicated that the year of interview of this subject can be greater than the year of diagnosis. They will be denoted as 1 and be excluded. Therefore, no futher actions are needed.  

```{r}
bc_dx_int %>% filter(is.na(diag_bef_intvw)) %>% 
  filter(diag_equl_intvw_yronly==1) %>% 
  mutate(diag_bef_intvw_yr_mth = case_when(
    date_int_mth+2 > date_dx_mth ~ 1,
    date_int_mth+2 < date_dx_mth ~ 0
  )) %>% group_by(diag_bef_intvw_yr_mth) %>% 
  summarize(n=n())

```

There are 4 subjects with equal years whose diagnosis months is later than interview months (+2 months).

There are 10 subjects with equal years whose diagnosis months is earlier than interview months (+2 months).

```{r}
# create a new variable for comparing months
bc_dx_int <- bc_dx_int %>% mutate(diag_bef_intvw_yr_mth = case_when(
  date_int_mth+2 > date_dx_mth ~ 1,
  date_int_mth+2 < date_dx_mth ~ 0
  ))

# use the indicator variable we built before to exclude those before interview date and 2 months before interview date.
# diag_bef_intvw indicate if the exact diagnosis date is before exact interview date
# 0 was denoted as subjects whose exact diagnosis dates are after exact interview date
# then, exclude those whose diagnosis dates are before interview day and interview date (+2 months)
# we only need new_id, b/c we can use it to select the row from the whole dataset
bc_int_bef_diag_id1 <- bc_dx_int %>% filter(diag_bef_intvw==0) %>% 
  filter(date_int_two_mth < date_dx) %>% pull(new_id)

# filter out those without exact date
# filtered by year using indicator variables 'diag_bef_intvw_yronly' and 'diag_bef_intvw_yronly'
# diag_bef_intvw_yronly:
# 0 was denoted as subjects whose diagnosis years are before or equal to interview years
# diag_equl_intvw_yronly:
# 0 was denoted as subjects whose diagnosis years are unequal to interview years
bc_int_bef_diag_id2 <-  bc_dx_int %>% 
  filter(is.na(diag_bef_intvw)) %>% 
  filter(diag_bef_intvw_yronly==0) %>% 
  filter(diag_equl_intvw_yronly==0) %>% 
  pull(new_id)

# diag_equl_intvw_yronly:
# 1 was denoted as subjects whose diagnosis years are equal to interview years
# diag_bef_intvw_yr_month is an indicator variable that determine if diagnosis month is greater than interview month (+ 2 months)
# diag_bef_intvw_yr_month: 
# 0 was denoted as subjects whose diagnosis months are greater than interview month (+ 2 months)
bc_int_bef_diag_id3 <- bc_dx_int %>% 
  filter(is.na(diag_bef_intvw)) %>% 
  filter(diag_equl_intvw_yronly==1) %>% 
  filter(diag_bef_intvw_yr_mth==0) %>% 
  pull(new_id)
  
# combine all subjects with date infomation whose diagnosis date is at least two months after interview date
bc_int_bef_diag_id <- c(bc_int_bef_diag_id1,
                        bc_int_bef_diag_id2,
                        bc_int_bef_diag_id3)

# get the number of subjects with date infomation whose diagnosis date is at least two months after interview date
length(bc_int_bef_diag_id)

# those 12 subjects are considered as missing
bc_dx_int_missmth_id <- bc_dx_int %>% 
  filter(is.na(diag_bef_intvw)) %>% 
  filter(diag_equl_intvw_yronly==1) %>% 
  filter(is.na(diag_bef_intvw_yr_mth)) %>% 
  pull(new_id)

```

We already acquired 861 unique subject id with diagnosis date after interview date (+2 months).

Now we need to compare those 861 subjects with subjects we got in bc_rx (questions about breast cancer diagnosis and mastectomy).

```{r}
# we combine two id variable and see if there are duplicated values
# both id variable are unique
sum(duplicated(c(bc_rx_nobc_id,bc_int_bef_diag_id)))

# there are 6 duplicated subjects
which(duplicated(c(bc_rx_nobc_id,bc_int_bef_diag_id)))

# we need to look at other 100 subjects who answered 'no' in their questions 
# exclude those with exact date 
bc_data7 %>% filter(new_id %in% bc_rx_nobc_id) %>% 
  select(new_id,dt_interview,age_interview,agedx,dxdate,dxest) %>% 
  filter(is.na(dxdate))

bc_rx_nadx_id <- bc_data7 %>% filter(new_id %in% bc_rx_nobc_id) %>% 
  select(new_id,dt_interview,age_interview,agedx,dxdate,dxest) %>% 
  filter(is.na(dxdate)) %>% 
  pull(new_id)

```

There are 16 subjects with NA in diagnosis date answered answer 'no', but We don't know if they were diagnosed within 2 months after interview.

There are 106-16-6=84 sunjects who asnwered no in questions but could be excluded during previous process of exclusion by comparison.

We checked the id of 12 subjects with incomplete information of diagnosis date. There is no overlapped subjects.

```{r}
# we can confirm there are 877 subjects with diagnosis date before interview date. 
bc_int_bef_diag_finid <- c(bc_int_bef_diag_id,bc_rx_nadx_id)




```








